{
  "labels": {
    "bubble": "Bubble Sort",
    "selection": "Selection Sort",
    "insertion": "Insertion Sort",
    "merge": "Merge Sort",
    "quick": "Quick Sort"
  },
  "info": {
    "bubble": {
      "best": "O(n)",
      "average": "O(n²)",
      "worst": "O(n²)",
      "space": "O(1)"
    },
    "selection": {
      "best": "O(n²)",
      "average": "O(n²)",
      "worst": "O(n²)",
      "space": "O(1)"
    },
    "insertion": {
      "best": "O(n)",
      "average": "O(n²)",
      "worst": "O(n²)",
      "space": "O(1)"
    },
    "merge": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n log n)",
      "space": "O(n)"
    },
    "quick": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n²)",
      "space": "O(log n)"
    }
  },
  "descriptions": {
    "bubble": "Bubble Sort works by repeatedly comparing and swapping adjacent elements until the list is sorted. It is best used for very small or nearly sorted arrays because it is simple but inefficient for large datasets.",
    "selection": "Selection Sort sorts by repeatedly selecting the smallest element from the unsorted part of the array and placing it in its correct position. It is best for small lists and situations where minimizing swaps is important, but it performs poorly on large datasets.",
    "insertion": "Insertion Sort builds the sorted array one element at a time by inserting each element into its proper position among previously sorted elements. It is best for small or nearly sorted arrays and performs efficiently in such cases.",
    "merge": "Merge Sort divides the array into smaller subarrays, sorts them, and then merges them back together in order. It is best for large datasets and when stable sorting is required, though it needs extra memory.",
    "quick": "Quick Sort sorts by choosing a pivot element, partitioning the array around it, and recursively sorting the partitions. It is best for large datasets and is generally the fastest sorting algorithm in practice."
  }
}
